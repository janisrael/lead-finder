name: Deploy to Production

on:
  push:
    branches:
      - main  # Main branch for production deployment (Hetzner Kubernetes)
  workflow_dispatch:

env:
  PYTHON_VERSION: '3.11'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Free disk space
        run: |
          echo "=== Checking disk space ==="
          df -h
          echo "=== Cleaning up disk space ==="
          pip cache purge || true
          sudo apt-get clean || true
          sudo rm -rf /usr/share/dotnet || true
          sudo rm -rf /opt/ghc || true
          sudo rm -rf /usr/local/share/boost || true
          sudo rm -rf "$AGENT_TOOLSDIRECTORY" || true
          sudo rm -rf ~/.cache/pip || true
          sudo rm -rf /tmp/* || true
          echo "=== Disk space after cleanup ==="
          df -h
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir -r requirements.txt
      
      - name: Check for syntax errors
        run: |
          python -m py_compile app.py
          find . -name "*.py" \
            -not -path "./venv*/*" \
            -not -path "./.git/*" \
            -not -path "./__pycache__/*" \
            -not -path "./data/*" \
            -not -path "./*.db" \
            -exec python -m py_compile {} \;
      
      - name: Verify imports
        run: |
          python -c "import app; print('App imports successfully')"
          python -c "from flask import Flask; print('Flask imports successfully')"
      
      - name: Cleanup after tests
        if: always()
        run: |
          echo "=== Final cleanup ==="
          pip cache purge || true
          sudo apt-get clean || true
          rm -rf __pycache__ || true
          find . -type d -name __pycache__ -exec rm -rf {} + || true

  deploy-production:
    name: Deploy to Production
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_PRIVATE_KEY }}" > ~/.ssh/hetzner_key
          chmod 600 ~/.ssh/hetzner_key
          ssh-keyscan -H ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts
      
      - name: Deploy to Hetzner Kubernetes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REF: ${{ github.ref }}
          GOOGLE_PLACES_API_KEY: ${{ secrets.GOOGLE_PLACES_API_KEY }}
          SSH_OPTS: "-i ~/.ssh/hetzner_key -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=30"
        run: |
          echo "=== Deploying to Hetzner Kubernetes ==="
          
          # Upload source code to Hetzner and build there (avoids GitHub Actions disk space issues)
          echo "=== Uploading source code to Hetzner ==="
          tar --exclude='.git' --exclude='venv' --exclude='__pycache__' --exclude='*.pyc' --exclude='.env' --exclude='data' --exclude='*.db' --exclude='*.sqlite*' --exclude='*.csv' --exclude='*.log' --exclude='*.zip' -czf /tmp/leadfinder-source.tar.gz .
          scp ${SSH_OPTS} /tmp/leadfinder-source.tar.gz root@${{ secrets.HETZNER_HOST }}:/tmp/
          rm -f /tmp/leadfinder-source.tar.gz
          
          # Build Docker image directly on Hetzner server
          echo "=== Building Docker image on Hetzner ==="
          ssh ${SSH_OPTS} root@${{ secrets.HETZNER_HOST }} bash -s << DEPLOY_SCRIPT
            set -e
            set -o pipefail
            
            # Set Google Places API key from GitHub Actions environment variable
            GOOGLE_PLACES_API_KEY='${GOOGLE_PLACES_API_KEY}'
            
            cd /tmp
            rm -rf leadfinder-build || true
            mkdir -p leadfinder-build
            cd leadfinder-build
            tar -xzf /tmp/leadfinder-source.tar.gz
            rm /tmp/leadfinder-source.tar.gz
            
            echo "Building Docker image (this may take several minutes)..."
            docker build -t leadfinder:latest . || {
              echo "Docker build failed"
              exit 1
            }
            
            echo "Importing image into k3s..."
            docker save leadfinder:latest | k3s ctr images import - || {
              echo "Image import failed"
              exit 1
            }
            
            echo "Applying Kubernetes manifests..."
            if [ ! -d "/tmp/leadfinder-k8s" ]; then
              mkdir -p /tmp/leadfinder-k8s
            fi
            cp -r k8s/* /tmp/leadfinder-k8s/ 2>/dev/null || true
            
            # Apply manifests if they exist
            if [ -d "/tmp/leadfinder-k8s" ] && [ "$(ls -A /tmp/leadfinder-k8s/*.yaml 2>/dev/null)" ]; then
              kubectl apply -f /tmp/leadfinder-k8s/namespace.yaml || true
              
              # Create/update secret with Google Places API key from GitHub Secrets
              echo "Creating/updating Kubernetes secret with Google Places API key..."
              kubectl create secret generic leadfinder-secrets \
                --from-literal=secret-key="\$(openssl rand -hex 32)" \
                --from-literal=flask-env='production' \
                --from-literal=port='5000' \
                --from-literal=google-places-api-key="\${GOOGLE_PLACES_API_KEY}" \
                --from-literal=debug='false' \
                -n leadfinder \
                --dry-run=client -o yaml | kubectl apply -f - || true
              
              echo "Secret created/updated successfully"
              
              kubectl apply -f /tmp/leadfinder-k8s/deployment.yaml || true
              kubectl apply -f /tmp/leadfinder-k8s/service.yaml || true
              kubectl apply -f /tmp/leadfinder-k8s/ingress.yaml || true
              
              echo "Restarting deployment..."
              kubectl rollout restart deployment/leadfinder-app -n leadfinder || {
                echo "Deployment restart failed"
                exit 1
              }
              
              kubectl rollout status deployment/leadfinder-app -n leadfinder --timeout=120s || {
                echo "Deployment status check timed out, but may still be in progress"
              }
            else
              echo "Kubernetes manifests not found, skipping kubectl apply"
            fi
            
            echo "Cleaning up..."
            cd /
            rm -rf /tmp/leadfinder-build
            rm -rf /tmp/leadfinder-k8s
            
            echo "Deployment complete"
          DEPLOY_SCRIPT
      
      - name: Verify deployment
        run: |
          sleep 10
          curl -f ${{ secrets.HETZNER_APP_URL || 'https://leadfinder.janisrael.com' }}/api/health || echo "Health check failed, but deployment may still be in progress"
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "Production deployment successful!"
          else
            echo "Production deployment failed!"
          fi

